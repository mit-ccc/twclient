/*
 * Database setup
 */

create extension if not exists tablefunc;

create or replace function unixtime_to_date(double precision)
  returns date as
$$
select to_char(to_timestamp($1) at time zone 'UTC', 'YYYY-MM-DD')::date
$$ language sql immutable;

create or replace function trigger_set_modified_dt()
returns trigger as $$
begin
  new.modified_dt = now();
  return new;
end;
$$ language plpgsql;

/*
 * Twitter data tables
 */

drop schema if exists twitter cascade;
create schema twitter;

drop table if exists twitter.user;
create table twitter.user
(
    -- this is the Twitter user id, not a surrogate key.
    -- it simplifies the load process to use it as pk.
    user_id bigint primary key,

    api_response jsonb,

    screen_name varchar(256),
    account_create_dt timestamptz,
    protected boolean,
    verified boolean,

    name text,
    description text,
    location text,
    url text,

    insert_dt timestamptz not null default now(),
    modified_dt timestamptz not null default now()
);
create index on twitter.user using btree (screen_name);

drop table if exists twitter.follow_fetch;
create table twitter.follow_fetch
(
    follow_fetch_id bigint
        generated by default as identity
        primary key,

    -- these are not strictly speaking necessary (you can compute them by
    -- checking which of source_user_id and target_user_id in twitter.follow
    -- matches this table's user_id), but they're convenient
    is_followers boolean not null,
    is_friends boolean not null,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    -- i.e., is_followers XOR is_friends
    check( is_followers::int + is_friends::int = 1 )
);
create index on twitter.follow_fetch using btree (follow_fetch_id, user_id);
create index on twitter.follow_fetch using btree (user_id, follow_fetch_id);

drop table if exists twitter.follow;
create table twitter.follow
(
    twitter_follow_id bigint
        generated by default as identity
        primary key,

    follow_fetch_id bigint
        not null
        references twitter.follow_fetch
        deferrable initially immediate,

    source_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    target_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    unique(follow_fetch_id, source_user_id, target_user_id)
);
create unique index on twitter.follow using btree
    (follow_fetch_id, target_user_id, source_user_id);

create index on twitter.follow using btree (target_user_id);
create index on twitter.follow using btree (source_user_id);

drop table if exists twitter.tweet;
create table twitter.tweet
(
    -- as in twitter.user, this is the Twitter id
    -- rather than a surrogate key
    tweet_id bigint primary key,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    content text not null check(length(content) > 0),
    api_response jsonb not null,
    tweet_create_dt timestamptz not null,

    lang varchar(8),
    source text,
    truncated boolean,

    retweeted_status_id bigint,

    quoted_status_id bigint,
    quoted_status_content text,

    in_reply_to_user_id bigint,
    in_reply_to_status_id bigint,

    retweet_count int,
    favorite_count int,

    insert_dt timestamptz not null default now(),
    modified_dt timestamptz not null default now()
);
create index on twitter.tweet using btree (user_id);

drop table if exists twitter.mention;
create table twitter.mention
(
    tweet_id bigint
        not null
        references twitter.tweet
        deferrable initially immediate,

    mentioned_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    primary key (tweet_id, mentioned_user_id)
);
create index on twitter.mention using btree (mentioned_user_id, tweet_id);

drop table if exists twitter.user_tag;
create table twitter.user_tag
(
    user_tag_id bigint
        generated by default as identity
        primary key,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    tag text not null,

    unique(user_id, tag)
);
create index on twitter.user_tag using btree (tag, user_id);

drop table if exists twitter.tweet_tag;
create table twitter.tweet_tag
(
    tweet_tag_id bigint
        generated by default as identity
        primary key,

    tweet_id bigint
        not null
        references twitter.tweet
        deferrable initially immediate,

    tag text not null,

    unique(tweet_id, tag)
);
create index on twitter.tweet_tag using btree (tag, tweet_id);

-- we're likely to run UPDATEs on these tables, need to track mtimes
create trigger set_modified_dt
before update on twitter.user
for each row
execute procedure trigger_set_modified_dt();

create trigger set_modified_dt
before update on twitter.tweet
for each row
execute procedure trigger_set_modified_dt();

/*
 * Analytics views
 */

drop schema if exists analytics cascade;
create schema analytics;

create or replace view analytics.summary_stats as
with users as
(
    select
        count(*) as users_loaded,
        coalesce(sum((u.api_response is not null)::int), 0) as users_populated
    from twitter.user u
),

tweets as
(
    select
        count(*) as tweets_loaded,
        count(distinct user_id) as users_with_tweets
    from twitter.tweet
),

mentions as
(
    select
        count(*) as mentions_loaded,
        count(distinct mentioned_user_id) as users_mentioned
    from twitter.mention
),

follows as
(
    select
        count(*) as follow_graph_edges,
        count(distinct source_user_id) as users_with_friends,
        count(distinct target_user_id) as users_with_followers
    from twitter.follow
)

select
    *
from users
    cross join tweets
    cross join mentions
    cross join follows;

create or replace view analytics.all_mentions as
select
    tw.tweet_id,

    tw.user_id as source_user_id,
    mt.mentioned_user_id as target_user_id,

    extract(epoch from tw.tweet_create_dt) as currency_dt
from twitter.tweet tw
    inner join twitter.mention mt using(tweet_id);

create or replace view analytics.all_replies as
select
    tw.tweet_id,

    tw.user_id as source_user_id,
    tw.in_reply_to_user_id as target_user_id,

    extract(epoch from tw.tweet_create_dt) as currency_dt
from twitter.tweet tw;

create or replace view analytics.mention_graph as
select
    tw.user_id as source_user_id,
    mt.mentioned_user_id as target_user_id,

    count(*) as mentions,

    min(extract(epoch from tw.tweet_create_dt)) as first_dt,
    max(extract(epoch from tw.tweet_create_dt)) as last_dt
from twitter.tweet tw
    inner join twitter.mention mt using(tweet_id)
group by 1,2;

create or replace view analytics.reply_graph as
select
    tw.user_id as source_user_id,
    tw.in_reply_to_user_id as target_user_id,

    count(*) as replies,

    min(extract(epoch from tw.tweet_create_dt)) as first_dt,
    max(extract(epoch from tw.tweet_create_dt)) as last_dt
from twitter.tweet tw
group by 1,2;

create or replace view analytics.tweets as
select
    tw.tweet_id,
    tw.user_id,

    regexp_replace(
        tw.content || coalesce(' ' || tw.quoted_status_content, ''),
        '[\n\r]+', ' ', 'g'
    ) as content,

    tw.tweet_create_dt,
    tw.lang,
    tw.source,
    tw.truncated,
    tw.retweeted_status_id is not null as is_retweet,
    tw.in_reply_to_status_id is not null as is_reply,
    tw.quoted_status_id is not null as is_quote_tweet,
    tw.retweet_count,
    tw.favorite_count,

    case tw.source
        when 'Twitter for iPhone' then 'iPhone'
        when 'Twitter for Android' then 'Android'
        when 'Twitter Web App' then 'Desktop'
        when 'Twitter Web Client' then 'Desktop'
        when 'TweetDeck' then 'Desktop'
        else 'Other'
    end as source_collapsed,

    tw.modified_dt as currency_dt
from twitter.tweet tw;

