/*
 * Database setup
 */

create extension if not exists tablefunc;

create or replace function unixtime_to_date(double precision)
  returns date as
$$
select to_char(to_timestamp($1) at time zone 'UTC', 'YYYY-MM-DD')::date
$$ language sql immutable;

create or replace function trigger_set_modified_dt()
returns trigger as $$
begin
  new.modified_dt = now();
  return new;
end;
$$ language plpgsql;

/*
 * Twitter data tables
 */

drop schema if exists twitter cascade;
create schema twitter;

drop table if exists twitter.user;
create table twitter.user
(
    -- this is the Twitter user id, not a surrogate key.
    -- it simplifies the load process to use it as pk.
    user_id bigint primary key,

    api_response jsonb,

    screen_name varchar(256),
    account_create_dt timestamptz,
    protected boolean,
    verified boolean,

    name text,
    description text,
    location text,
    url text,

    insert_dt timestamptz not null default now(),
    modified_dt timestamptz not null default now()
);
create index on twitter.user using btree (screen_name);

drop table if exists twitter.follow_fetch;
create table twitter.follow_fetch
(
    follow_fetch_id bigint
        generated by default as identity
        primary key,

    -- these are not strictly speaking necessary (you can compute them by
    -- checking which of source_user_id and target_user_id in twitter.follow
    -- matches this table's user_id), but they're convenient
    is_followers boolean not null,
    is_friends boolean not null,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    -- i.e., is_followers XOR is_friends
    check( is_followers::int + is_friends::int = 1 )
);
create index on twitter.follow_fetch using btree (follow_fetch_id, user_id);
create index on twitter.follow_fetch using btree (user_id, follow_fetch_id);

drop table if exists twitter.follow;
create table twitter.follow
(
    twitter_follow_id bigint
        generated by default as identity
        primary key,

    follow_fetch_id bigint
        not null
        references twitter.follow_fetch
        deferrable initially immediate,

    source_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    target_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    unique(follow_fetch_id, source_user_id, target_user_id)
);
create unique index on twitter.follow using btree
    (follow_fetch_id, target_user_id, source_user_id);

create index on twitter.follow using btree (target_user_id);
create index on twitter.follow using btree (source_user_id);

drop table if exists twitter.tweet;
create table twitter.tweet
(
    -- as in twitter.user, this is the Twitter id
    -- rather than a surrogate key
    tweet_id bigint primary key,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    content text not null check(length(content) > 0),
    api_response jsonb not null,
    tweet_create_dt timestamptz not null,

    lang varchar(8),
    source text,
    truncated boolean,

    retweeted_status_id bigint,

    quoted_status_id bigint,
    quoted_status_content text,

    in_reply_to_user_id bigint,
    in_reply_to_status_id bigint,

    retweet_count int,
    favorite_count int,

    insert_dt timestamptz not null default now(),
    modified_dt timestamptz not null default now()
);
create index on twitter.tweet using btree (user_id);

drop table if exists twitter.mention;
create table twitter.mention
(
    tweet_id bigint
        not null
        references twitter.tweet
        deferrable initially immediate,

    mentioned_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    primary key (tweet_id, mentioned_user_id)
);
create index on twitter.mention using btree (mentioned_user_id, tweet_id);

drop table if exists twitter.user_tag;
create table twitter.user_tag
(
    user_tag_id bigint
        generated by default as identity
        primary key,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    tag text not null,

    unique(user_id, tag)
);
create index on twitter.user_tag using btree (tag, user_id);

drop table if exists twitter.tweet_tag;
create table twitter.tweet_tag
(
    tweet_tag_id bigint
        generated by default as identity
        primary key,

    tweet_id bigint
        not null
        references twitter.tweet
        deferrable initially immediate,

    tag text not null,

    unique(tweet_id, tag)
);
create index on twitter.tweet_tag using btree (tag, tweet_id);

-- we're likely to run UPDATEs on these tables, need to track mtimes
create trigger set_modified_dt
before update on twitter.user
for each row
execute procedure trigger_set_modified_dt();

create trigger set_modified_dt
before update on twitter.tweet
for each row
execute procedure trigger_set_modified_dt();

