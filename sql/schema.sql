/*
 * Database setup
 */

create extension if not exists tablefunc;

create or replace function trigger_set_modified_dt()
returns trigger as $$
begin
  new.modified_dt = now();
  return new;
end;
$$ language plpgsql;

drop schema if exists dim cascade;
create schema dim;

drop table if exists dim.integer;
create table dim.integer
(
    n int primary key
);

begin;
    insert into dim.integer (n) values (0);
    insert into dim.integer (n) values (1);
    insert into dim.integer (n) values (2);
    insert into dim.integer (n) values (3);
    insert into dim.integer (n) values (4);
    insert into dim.integer (n) values (5);
    insert into dim.integer (n) values (6);
    insert into dim.integer (n) values (7);
    insert into dim.integer (n) values (8);
    insert into dim.integer (n) values (9);
commit;

drop table if exists dim.date;
create table dim.date
(
    date date primary key
);

begin;
    insert into dim.date
        (date)
    select
        '1900-01-01'::date + (x.n::text || ' days')::interval
    from
    (
        select
            i0.n + 10*i1.n + 100*i2.n + 1000*i3.n + 10000*i4.n as n
        from dim.integer i0
            cross join dim.integer i1
            cross join dim.integer i2
            cross join dim.integer i3
            cross join dim.integer i4
    ) x
    where
        '1900-01-01'::date + (x.n::text || ' days')::interval <= '2050-01-01';
commit;

/*
 * Twitter data tables
 */

drop schema if exists twitter cascade;
create schema twitter;

drop table if exists twitter.user;
create table twitter.user
(
    -- this is the Twitter user id, not a surrogate key.
    -- it simplifies the load process to use it as pk.
    user_id bigint primary key,

    api_response jsonb,

    screen_name varchar(256),
    account_create_dt timestamptz,
    protected boolean,
    verified boolean,

    name text,
    description text,
    location text,
    url text,

    insert_dt timestamptz not null default now(),
    modified_dt timestamptz not null default now()
);
create index on twitter.user using btree (screen_name);

drop table if exists twitter.follow_fetch;
create table twitter.follow_fetch
(
    follow_fetch_id bigint
        generated by default as identity
        primary key,

    -- these are not strictly speaking necessary (you can compute them by
    -- checking which of source_user_id and target_user_id in twitter.follow
    -- matches this table's user_id), but they're convenient
    is_followers boolean not null,
    is_friends boolean not null,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    -- i.e., is_followers XOR is_friends
    check( is_followers::int + is_friends::int = 1 )
);
create index on twitter.follow_fetch using btree (follow_fetch_id, user_id);
create index on twitter.follow_fetch using btree (user_id, follow_fetch_id);

drop table if exists twitter.follow;
create table twitter.follow
(
    twitter_follow_id bigint
        generated by default as identity
        primary key,

    follow_fetch_id bigint
        not null
        references twitter.follow_fetch
        deferrable initially immediate,

    source_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    target_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    unique(follow_fetch_id, source_user_id, target_user_id)
);
create unique index on twitter.follow using btree
    (follow_fetch_id, target_user_id, source_user_id);

create index on twitter.follow using btree (target_user_id);
create index on twitter.follow using btree (source_user_id);

drop table if exists twitter.tweet;
create table twitter.tweet
(
    -- as in twitter.user, this is the Twitter id
    -- rather than a surrogate key
    tweet_id bigint primary key,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    content text not null check(length(content) > 0),
    api_response jsonb not null,
    tweet_create_dt timestamptz not null,

    lang varchar(8),
    source text,
    truncated boolean,

    retweeted_status_id bigint,

    quoted_status_id bigint,
    quoted_status_content text,

    in_reply_to_user_id bigint,
    in_reply_to_status_id bigint,

    retweet_count int,
    favorite_count int,

    insert_dt timestamptz not null default now(),
    modified_dt timestamptz not null default now()
);
create index on twitter.tweet using btree (user_id);
create index on twitter.tweet using btree (tweet_create_dt);

drop table if exists twitter.mention;
create table twitter.mention
(
    tweet_id bigint
        not null
        references twitter.tweet
        deferrable initially immediate,

    mentioned_user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    insert_dt timestamptz not null default now(),

    primary key (tweet_id, mentioned_user_id)
);
create index on twitter.mention using btree (mentioned_user_id, tweet_id);

drop table if exists twitter.user_tag;
create table twitter.user_tag
(
    user_tag_id bigint
        generated by default as identity
        primary key,

    user_id bigint
        not null
        references twitter.user
        deferrable initially immediate,

    tag text not null,

    unique(user_id, tag)
);
create index on twitter.user_tag using btree (tag, user_id);

drop table if exists twitter.tweet_tag;
create table twitter.tweet_tag
(
    tweet_tag_id bigint
        generated by default as identity
        primary key,

    tweet_id bigint
        not null
        references twitter.tweet
        deferrable initially immediate,

    tag text not null,

    unique(tweet_id, tag)
);
create index on twitter.tweet_tag using btree (tag, tweet_id);

-- we're likely to run UPDATEs on these tables, need to track mtimes
create trigger set_modified_dt
before update on twitter.user
for each row
execute procedure trigger_set_modified_dt();

create trigger set_modified_dt
before update on twitter.tweet
for each row
execute procedure trigger_set_modified_dt();

/*
 * Analytics views - some live, some materialized
 */

drop schema if exists analytics cascade;
create schema analytics;

create or replace view analytics.summary_stats_live as
with users as
(
    select
        count(*) as users_loaded,
        coalesce(sum((u.api_response is not null)::int), 0) as users_populated
    from twitter.user u
),

tweets as
(
    select
        count(*) as tweets_loaded,
        count(distinct user_id) as users_with_tweets
    from twitter.tweet
),

mentions as
(
    select
        count(*) as mentions_loaded,
        count(distinct mentioned_user_id) as users_mentioned
    from twitter.mention
),

follows as
(
    select
        count(*) as follow_graph_edges,
        count(distinct source_user_id) as users_with_friends,
        count(distinct target_user_id) as users_with_followers
    from twitter.follow
)

select
    *
from users
    cross join tweets
    cross join mentions
    cross join follows;

create or replace view analytics.all_mentions_live as
select
    tw.tweet_id,

    tw.user_id as source_user_id,
    mt.mentioned_user_id as target_user_id,

    extract(epoch from tw.tweet_create_dt) as currency_dt
from twitter.tweet tw
    inner join twitter.mention mt using(tweet_id);

create or replace view analytics.all_replies_live as
select
    tw.tweet_id,

    tw.user_id as source_user_id,
    tw.in_reply_to_user_id as target_user_id,

    extract(epoch from tw.tweet_create_dt) as currency_dt
from twitter.tweet tw;

drop materialized view if exists analytics.mention_graph_materialized;
create materialized view analytics.mention_graph_materialized as
select
    tw.user_id as source_user_id,
    mt.mentioned_user_id as target_user_id,

    count(*) as mentions,

    min(tw.tweet_create_dt) as first_dt,
    max(tw.tweet_create_dt) as last_dt
from twitter.tweet tw
    inner join twitter.mention mt using(tweet_id)
group by 1,2;

drop materialized view if exists analytics.reply_graph_materialized;
create materialized view analytics.reply_graph_materialized as
select
    tw.user_id as source_user_id,
    tw.in_reply_to_user_id as target_user_id,

    count(*) as replies,

    min(tw.tweet_create_dt) as first_dt,
    max(tw.tweet_create_dt) as last_dt
from twitter.tweet tw
group by 1,2;

create or replace function reply_graph_by_time(
    _start timestamp,
    _end timestamp
)
returns table (
    source_user_id bigint,
    target_user_id bigint,

    replies bigint,

    first_dt timestamp
    last_dt timestamp
) as
$func$
select
    tw.user_id as source_user_id,
    tw.in_reply_to_user_id as target_user_id,

    count(*) as replies,

    min(tw.tweet_create_dt) as first_dt,
    max(tw.tweet_create_dt) as last_dt
from twitter.tweet tw
where
    tw.tweet_create_dt >= $1 and
    tw.tweet_create_dt <= $2
group by 1,2;
$func$ language sql;

create or replace function mention_graph_by_time(
    _start timestamp,
    _end timestamp
)
returns table (
    source_user_id bigint,
    target_user_id bigint,

    mentions bigint,

    first_dt timestamp
    last_dt timestamp
) as
$func$
select
    tw.user_id as source_user_id,
    mt.mentioned_user_id as target_user_id,

    count(*) as mentions,

    min(tw.tweet_create_dt) as first_dt,
    max(tw.tweet_create_dt) as last_dt
from twitter.tweet tw
    inner join twitter.mention mt using(tweet_id)
where
    tw.tweet_create_dt >= $1 and
    tw.tweet_create_dt <= $2
group by 1,2;
$func$ language sql;

create or replace view analytics.tweets_live as
select
    tw.tweet_id,
    tw.user_id,

    regexp_replace(
        tw.content || coalesce(' ' || tw.quoted_status_content, ''),
        '[\n\r]+', ' ', 'g'
    ) as content,

    tw.tweet_create_dt,
    tw.lang,
    tw.source,
    tw.truncated,
    tw.retweeted_status_id is not null as is_retweet,
    tw.in_reply_to_status_id is not null as is_reply,
    tw.quoted_status_id is not null as is_quote_tweet,
    tw.retweet_count,
    tw.favorite_count,

    case tw.source
        when 'Twitter for iPhone' then 'iPhone'
        when 'Twitter for Android' then 'Android'
        when 'Twitter Web App' then 'Desktop'
        when 'Twitter Web Client' then 'Desktop'
        when 'TweetDeck' then 'Desktop'
        else 'Other'
    end as source_collapsed,

    tw.modified_dt as currency_dt
from twitter.tweet tw;

drop materialized view if exists analytics.tweet_activity_by_date_materialized;
create materialized view analytics.tweet_activity_by_date_materialized as
with
    tmp_date_range as
    (
        select
            min(tw.tweet_create_dt) as start_timestamp,
            max(tw.tweet_create_dt) as end_timestamp,

            min(tw.tweet_create_dt) as start_date,
            max(tw.tweet_create_dt) as end_date
        from twitter.tweet tw
    ),

    tmp_universe as
    (
        select
            u.user_id
        from twitter.user u
        where
            -- only manually loaded users, not e.g. those who are just followed
            -- by a user we're interested in
            u.api_response is not null
    ),

    tmp_user_date as
    (
        select
            tu.user_id,
            td.date
        from tmp_universe tu
            cross join dim.date td
            cross join tmp_date_range tdr
        where
            td.date >= tdr.start_date and
            td.date <= tdr.end_date
    ),

    tmp_tweet_stats_per_day as
    (
        select
            tu.user_id,
            date(tw.tweet_create_dt) as date,

            count(*) as tweets,
            count(tw.retweeted_status_id) as retweets,
            sum(tw.retweet_count) as retweeted,
            sum(tw.favorite_count) as liked
        from tmp_universe tu
            inner join twitter.tweet tw using(user_id)
        group by 1,2
    ),

    tmp_mentions_per_day as
    (
        select
            tu.user_id,
            date(tw.tweet_create_dt) as date,

            count(*) as mentions
        from tmp_universe tu
            inner join twitter.tweet tw using(user_id)
            inner join twitter.mention mt using(tweet_id)
        group by 1,2
    ),

    tmp_mentioned_per_day_universe as
    (
        select
            tu.user_id,
            date(tw.tweet_create_dt) as date,

            count(*) as mentioned_universe
        from tmp_universe tu
            inner join twitter.mention mt on mt.mentioned_user_id = tu.user_id
            inner join twitter.tweet tw using(tweet_id)
        group by 1,2
    ),

    tmp_replies_per_day as
    (
        select
            ut.user_id,
            date(tw.tweet_create_dt) as date,

            count(*) as replies
        from tmp_universe ut
            inner join twitter.tweet tw using(user_id)
        where
            tw.in_reply_to_user_id is not null
        group by 1,2
    ),

    tmp_replied_per_day_universe as
    (
        select
            ut.user_id,
            date(tw.tweet_create_dt) as date,

            count(*) as replied_universe
        from tmp_universe ut
            inner join twitter.tweet tw on tw.in_reply_to_user_id = ut.user_id
        group by 1,2
    ),

    tmp_account_ages as
    (
        select
            tud.user_id,
            tud.date,

            tud.date - date(u.account_create_dt) as account_age_in_days
        from tmp_user_date tud
            inner join twitter.user u using(user_id)
    ),

    tmp_days_since_last_tweet as
    (
        select
            x.user_id,
            x.date,
            x.tweeted_date,

            x.cce,

            first_value(x.tweeted_date) over (
                partition by x.user_id, x.cce
                order by x.date
            ) as most_recent_tweet_date,

            x.date - first_value(x.tweeted_date) over (
                partition by x.user_id, x.cce
                order by x.date
            ) as days_since_last_tweet
        from
        (
            select
                tud.user_id,
                tud.date,

                tts.date as tweeted_date,

                count(tts.date) over (
                    partition by tud.user_id
                    order by tud.date
                ) as cce
            from tmp_user_date tud
                left join tmp_tweet_stats_per_day tts using(user_id, date)
        ) x
    )
select
    tud.user_id,
    tud.date,

    taa.account_age_in_days,

    coalesce(tts.tweets, 0) as tweets,
    coalesce(tts.retweets, 0) as retweets,
    coalesce(tts.retweeted, 0) as retweeted,
    coalesce(tts.liked, 0) as liked,

    coalesce(tms.mentions, 0) as mentions,
    coalesce(tmd.mentioned_universe, 0) as mentioned_universe,

    coalesce(trs.replies, 0) as replies,
    coalesce(trd.replied_universe, 0) as replied_universe,

    coalesce(tds.days_since_last_tweet, 100) as days_since_last_tweet
from tmp_user_date tud
    left join tmp_account_ages taa using(user_id, date)
    left join tmp_tweet_stats_per_day tts using(user_id, date)
    left join tmp_mentions_per_day tms using(user_id, date)
    left join tmp_mentioned_per_day_universe tmd using(user_id, date)
    left join tmp_replies_per_day trs using(user_id, date)
    left join tmp_replied_per_day_universe trd using(user_id, date)
    left join tmp_days_since_last_tweet tds using(user_id, date);

